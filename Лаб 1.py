import requests #Импортирует библиотеку requests. Она нужна для отправки HTTP-запросов (в данном случае — для получения данных о погоде с сайта).
import pandas as pd #Импортируем pandas, чтобы удобно работать с табличными данными как с DataFrame.Именно в DataFrame мы будем хранить наш погодный датасет.
from datetime import date, timedelta  #Из модуля datetime импортирует два класса: date (для работы с датами) и timedelta (для работы с промежутками времени, например, "минус 3 дня").
from sklearn.model_selection import train_test_split  # Из библиотеки scikit-learn (инструменты для машинного обучения) импортирует функцию train_test_split. Она будет случайно разбивать данные на две части: для обучения модели и для её проверки.
from sklearn.linear_model import LinearRegression     # Импортирует класс LinearRegression — самую простую модель линейной регрессии, которая будет учиться предсказывать температуру.
from sklearn.metrics import mean_squared_error        # Импортирует функцию для расчета ошибки mean_squared_error (среднеквадратичная ошибка). Она покажет, насколько предсказания модели отличаются от реальных значений.
import numpy as np#числовые операции

latitude = 56.9496    
longitude = 24.1052#Задает географические координаты (широту и долготу) для места, погоду по которому мы хотим получить. Это координаты Риги, Латвия.
end_date = date.today() - timedelta(days=3)  # берем данные до 3 дней назад (данные могут быть не загружены)
start_date = end_date - timedelta(days=365*2)  #берем данные последних двух лет 
timezone = "Europe/Moscow"#Указываем тайм зону 

base_url = "https://archive-api.open-meteo.com/v1/archive" #Сохраняет в переменную base_url адрес (конечную точку) веб-сервиса (API), откуда мы будем брать архивные данные о погоде.
params = { # Создает словарь params с параметрами для нашего запроса.
    "latitude": latitude,# координаты 
    "longitude": longitude,# координаты 
    "start_date": start_date.isoformat(),# период запроса 
    "end_date": end_date.isoformat(),# период запроса 
    "daily": "temperature_2m_max,temperature_2m_min,precipitation_sum",# запрашиваем дневные параметры макс,мин,сумарные осадки 
    "timezone": timezone # чтобы даты были в человека понятном формате 
}

resp = requests.get(base_url, params=params) # Отправляет на сервер GET-запрос по адресу base_url, передавая в него наши параметры (params). Ответ сервера сохраняется в переменную resp.
resp.raise_for_status()  # Проверяет ответ сервера. Если сервер вернул ошибку (например, код 404 "Не найдено" или 500 "Внутренняя ошибка сервера"), эта строчка остановит выполнение программы и покажет текст ошибки. Если всё хорошо, код продолжит работу.
data = resp.json() #Преобразует ответ сервера (который пришел в текстовом формате JSON) в понятный для Python объект — словарь или список — и сохраняет в переменную data.

daily = data.get("daily", {}) #Из полученных данных (data) пытается извлечь значение по ключу "daily". Если такого ключа нет, вернется пустой словарь {}. В daily будут лежать массивы с ежедневными данными.
df = pd.DataFrame({ # создаем таблицу с колонками 
    "date": pd.to_datetime(daily.get("time")),# время 
    "tmax": daily.get("temperature_2m_max"),# макс температура
    "tmin": daily.get("temperature_2m_min"),# мин температура 
    "precip": daily.get("precipitation_sum")#  осадки 
})


df = df.sort_values("date").reset_index(drop=True)#сортирует строки таблицы по дате (от самой старой к самой новой). Это важно для создания признаков на основе предыдущих дней.

df["tmax_next_day"] = df["tmax"].shift(-1)  #Создает новый столбец tmax_next_day. Функция .shift(-1) сдвигает весь столбец tmax на одну строку вверх. Таким образом, в каждой строке в tmax_next_day окажется значение максимальной температуры на следующий день. Это наша целевая переменная (y) — то, что модель будет учиться предсказывать.
df = df.dropna(subset=["tmax_next_day"]).reset_index(drop=True)#Удаляем последнюю строку, где не было данных следующего дня.

df["tmax_lag1"] = df["tmax"].shift(1)  # Создает новый признак (фичу) — температуру предыдущего дня. .shift(1) сдвигает столбец tmax на 1 строку вниз. Для первой строки (самого первого дня в данных) здесь будет NaN.
df["tmax_lag1"].fillna(df["tmax"].mean(), inplace=True)  # Заполняет пропущенные значения (NaN) в столбце tmax_lag1 средним значением температуры по всему столбцу tmax. inplace=True означает, что изменение нужно произвести прямо в существующем столбце, а не создавать новый.
df["t_range"] = df["tmax"] - df["tmin"]#Создает новый признак — дневной перепад температуры (разницу между максимумом и минимумом за день). Это может быть полезно для модели.
df["day_of_year"] = df["date"].dt.dayofyear# получаем номер дня в году 

feature_cols = ["tmax", "tmin", "precip", "tmax_lag1", "t_range", "day_of_year"]#Список признаков, которые будут входить в модель.
X = df[feature_cols].astype(float)#Создает матрицу признаков X, выбирая из таблицы только нужные столбцы. .astype(float) гарантирует, что все данные будут числового типа float (числа с плавающей запятой), что требуется для модели.
y = df["tmax_next_day"].astype(float)#Создает вектор целевой переменной y — тот самый столбец с температурой на следующий день, который мы хотим предсказывать.


X_train, X_test, y_train, y_test = train_test_split(
    X, y, test_size=0.2, shuffle=False  # Разбивает данные (X и y) на обучающую и тестовую выборки.test_size=0.2 означает, что 20% данных пойдет на тест, а 80% — на обучение.shuffle=False ВАЖНО: мы отключаем случайное перемешивание, чтобы тестовая выборка всегда состояла из самых последних дней в нашем наборе данных. Это правильно для прогнозирования временных рядов: мы учимся на прошлом, а проверяем на будущем (относительном).
)

model = LinearRegression()#Создает экземпляр (объект) модели линейной регрессии.
model.fit(X_train, y_train)#обучаем модель на исторических данных модель анализирует данные X_train и y_train, находит математические закономерности (коэффициенты линейного уравнения), чтобы по X максимально точно предсказывать y.
y_pred = model.predict(X_test)#Получаем предсказания температуры на тестовом наборе.
rmse = np.sqrt(mean_squared_error(y_test, y_pred)) #Вычисляем корень из среднеквадратичной ошибки (RMSE) — популярная метрика в задачах регрессии.

print(f"Данные с {start_date.isoformat()} по {end_date.isoformat()} для локации ({latitude},{longitude})")# Сообщаем пользователю, за какой период загружены данные.
print(f"Размер датасета: {len(df)} строк")#Печатаем, сколько строк данных получили из API.
print(f"RMSE на тесте: {rmse:.3f} °C")#Печатаем ошибку модели в градусах Цельсия.

result = X_test.copy()#Копируем тестовые признаки.
result["actual_tmax_next_day"] = y_test.values#добовляем в таблицу значения температуры             Создает новую таблицу result для наглядности. К копии тестовых признаков (X_test) добавляются два столбца: реальная температура следующего дня (actual_...) и предсказанная моделью (pred_...).
result["pred_tmax_next_day"] = y_pred# предсказанные моделью 
print("\nПримеры (последние 5 строк теста):")#выводим последние пять столбцов 
print(result.tail(5))#
